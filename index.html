import React, { useState, useEffect, useRef } from 'react';
import { LucideDices, LucideCrown, LucideArrowLeft, LucideUsers, LucidePlay, LucideStar, LucideHelpCircle } from 'lucide-react';

// --- Helper-Funktionen & Konfiguration ---

const COLORS = ['red', 'green', 'yellow', 'blue'];

const START_POSITIONS = {
  red: [0, 1, 11, 12], green: [9, 10, 20, 21], blue: [99, 100, 110, 111], yellow: [108, 109, 119, 120],
};

const PATH = [
  44, 45, 46, 47, 48, 37, 26, 15, 4, 5, 6, 17, 28, 39, 50, 51, 52, 53, 54, 65,
  76, 75, 74, 73, 72, 83, 94, 105, 116, 115, 114, 103, 92, 81, 70, 69, 68, 67, 66, 55
];

const PATH_START_CELL = { red: 44, green: 6, yellow: 76, blue: 114 };
const PATH_START_INDEX = { red: 0, green: 10, yellow: 20, blue: 30 };

const FINISH_LINE_CELLS = {
  red: [56, 57, 58, 59], green: [16, 27, 38, 49], yellow: [64, 63, 62, 61], blue: [104, 93, 82, 71],
};

const EVENT_FIELDS = [PATH[5], PATH[15], PATH[25], PATH[35]];
const EVENTS = [
    { name: 'Flugzeugfeld', emoji: 'âœˆï¸', effect: 'fly', description: 'Du fliegst 5 Felder weiter nach vorne! Steht dort jemand, wird er rausgeworfen.' },
    { name: 'Tauschfeld', emoji: 'ðŸ”„', effect: 'swap', description: 'Tausche deine Position mit einer beliebigen anderen Figur auf dem Feld.' },
    { name: 'Polizeikontrolle', emoji: 'ðŸ‘®', effect: 'police', description: 'Du wurdest geblitzt! Gehe 3 Felder zurÃ¼ck.' },
    { name: 'Chaosfeld', emoji: 'ðŸŽ²', effect: 'chaos', description: 'WÃ¼rfle nochmal! Gerade Zahl: vorwÃ¤rts, ungerade Zahl: rÃ¼ckwÃ¤rts.' },
];

const QUIZ_FIELDS = [PATH[3], PATH[13], PATH[23], PATH[33]];
const QUIZ_QUESTIONS = [
    { question: 'Wie viele Liter Bier trinken die Deutschen durchschnittlich pro Kopf und Jahr?', answers: [{text: 'Ca. 100 Liter', isCorrect: true}, {text: 'Ca. 50 Liter', isCorrect: false}, {text: 'Ca. 150 Liter', isCorrect: false}] },
    { question: 'Wie hoch ist der Eiffelturm in Paris (inkl. Antennen)?', answers: [{text: '286 Meter', isCorrect: false}, {text: '330 Meter', isCorrect: true}, {text: '381 Meter', isCorrect: false}] },
    { question: 'Wie viele Herzen hat ein Oktopus?', answers: [{text: 'Eins', isCorrect: false}, {text: 'Zwei', isCorrect: false}, {text: 'Drei', isCorrect: true}] },
    { question: 'Wie lange dauert es, bis das Licht von der Sonne die Erde erreicht?', answers: [{text: '8 Minuten', isCorrect: true}, {text: '30 Sekunden', isCorrect: false}, {text: '2 Stunden', isCorrect: false}] },
    { question: 'Welches Land hat die meisten Inseln?', answers: [{text: 'Indonesien', isCorrect: false}, {text: 'Schweden', isCorrect: true}, {text: 'Kanada', isCorrect: false}] },
    { question: 'Wie viele Punkte hat ein MarienkÃ¤fer mit sieben Punkten?', answers: [{text: 'Sieben', isCorrect: true}, {text: 'Zweiundzwanzig', isCorrect: false}, {text: 'Es variiert', isCorrect: false}]},
    { question: 'Welcher Planet in unserem Sonnensystem ist der grÃ¶ÃŸte?', answers: [{text: 'Erde', isCorrect: false}, {text: 'Jupiter', isCorrect: true}, {text: 'Saturn', isCorrect: false}]},
    { question: 'Wie viele Knochen hat ein erwachsener menschlicher KÃ¶rper?', answers: [{text: '206', isCorrect: true}, {text: '300', isCorrect: false}, {text: '152', isCorrect: false}]},
    { question: 'Was ist die Hauptstadt von Australien?', answers: [{text: 'Sydney', isCorrect: false}, {text: 'Melbourne', isCorrect: false}, {text: 'Canberra', isCorrect: true}]},
    { question: 'Wie viele Tasten hat ein klassisches Klavier?', answers: [{text: '88', isCorrect: true}, {text: '76', isCorrect: false}, {text: '92', isCorrect: false}]},
    { question: 'Welches Tier ist das schnellste Landtier?', answers: [{text: 'LÃ¶we', isCorrect: false}, {text: 'Gepard', isCorrect: true}, {text: 'Antilope', isCorrect: false}]},
    { question: 'In welchem Jahr fiel die Berliner Mauer?', answers: [{text: '1989', isCorrect: true}, {text: '1991', isCorrect: false}, {text: '1987', isCorrect: false}]},
    { question: 'Wie viele ZÃ¤hne hat ein erwachsener Mensch normalerweise?', answers: [{text: '28', isCorrect: false}, {text: '32', isCorrect: true}, {text: '36', isCorrect: false}]},
    { question: 'Welcher Ozean ist der grÃ¶ÃŸte der Welt?', answers: [{text: 'Atlantischer Ozean', isCorrect: false}, {text: 'Indischer Ozean', isCorrect: false}, {text: 'Pazifischer Ozean', isCorrect: true}]},
    { question: 'Wer schrieb "Harry Potter"?', answers: [{text: 'J.R.R. Tolkien', isCorrect: false}, {text: 'J.K. Rowling', isCorrect: true}, {text: 'George R.R. Martin', isCorrect: false}]},
    { question: 'Wie viele Streifen hat die Flagge der USA?', answers: [{text: '13', isCorrect: true}, {text: '15', isCorrect: false}, {text: '12', isCorrect: false}]},
    { question: 'Welches Element hat das chemische Symbol "Au"?', answers: [{text: 'Silber', isCorrect: false}, {text: 'Gold', isCorrect: true}, {text: 'Kupfer', isCorrect: false}]},
    { question: 'Wie heiÃŸt der hÃ¶chste Berg der Welt?', answers: [{text: 'K2', isCorrect: false}, {text: 'Mount Everest', isCorrect: true}, {text: 'KangchendzÃ¶nga', isCorrect: false}]},
    { question: 'Welches Land ist fÃ¼r seine Tulpen berÃ¼hmt?', answers: [{text: 'Belgien', isCorrect: false}, {text: 'Niederlande', isCorrect: true}, {text: 'DÃ¤nemark', isCorrect: false}]},
    { question: 'Wie viele Spieler hat eine FuÃŸballmannschaft auf dem Feld?', answers: [{text: '11', isCorrect: true}, {text: '10', isCorrect: false}, {text: '12', isCorrect: false}]},
    { question: 'Wie viele Beine hat eine Spinne?', answers: [{text: '6', isCorrect: false}, {text: '8', isCorrect: true}, {text: '10', isCorrect: false}]},
    { question: 'Was ist die am hÃ¤ufigsten gesprochene Sprache der Welt?', answers: [{text: 'Englisch', isCorrect: false}, {text: 'Spanisch', isCorrect: false}, {text: 'Mandarin-Chinesisch', isCorrect: true}]},
    { question: 'In welchem Land wurde das Schachspiel erfunden?', answers: [{text: 'Indien', isCorrect: true}, {text: 'China', isCorrect: false}, {text: 'Ã„gypten', isCorrect: false}]},
    { question: 'Wie viele Planeten gibt es in unserem Sonnensystem?', answers: [{text: '8', isCorrect: true}, {text: '9', isCorrect: false}, {text: '7', isCorrect: false}]},
    { question: 'Welches ist das einzige SÃ¤ugetier, das fliegen kann?', answers: [{text: 'FlughÃ¶rnchen', isCorrect: false}, {text: 'Fledermaus', isCorrect: true}, {text: 'Pinguin', isCorrect: false}]},
    { question: 'Wie viele Farben hat ein Regenbogen?', answers: [{text: '6', isCorrect: false}, {text: '7', isCorrect: true}, {text: '8', isCorrect: false}]},
    { question: 'Welches Land hat die Form eines Stiefels?', answers: [{text: 'Griechenland', isCorrect: false}, {text: 'Italien', isCorrect: true}, {text: 'Spanien', isCorrect: false}]},
    { question: 'Wer malte die Mona Lisa?', answers: [{text: 'Vincent van Gogh', isCorrect: false}, {text: 'Leonardo da Vinci', isCorrect: true}, {text: 'Pablo Picasso', isCorrect: false}]},
    { question: 'Wie viele Kontinente gibt es?', answers: [{text: '5', isCorrect: false}, {text: '6', isCorrect: false}, {text: '7', isCorrect: true}]},
    { question: 'Was ist die WÃ¤hrung von Japan?', answers: [{text: 'Yuan', isCorrect: false}, {text: 'Yen', isCorrect: true}, {text: 'Won', isCorrect: false}]},
    { question: 'Wie viele Seiten hat ein WÃ¼rfel?', answers: [{text: '6', isCorrect: true}, {text: '8', isCorrect: false}, {text: '4', isCorrect: false}]},
    { question: 'Welches ist das lÃ¤ngste Fluss der Welt?', answers: [{text: 'Amazonas', isCorrect: false}, {text: 'Nil', isCorrect: true}, {text: 'Jangtse', isCorrect: false}]},
    { question: 'Wie viele Ringe hat das olympische Logo?', answers: [{text: '5', isCorrect: true}, {text: '4', isCorrect: false}, {text: '6', isCorrect: false}]},
    { question: 'Wer war der erste Mensch im Weltraum?', answers: [{text: 'Neil Armstrong', isCorrect: false}, {text: 'Yuri Gagarin', isCorrect: true}, {text: 'Buzz Aldrin', isCorrect: false}]},
    { question: 'Welches Gas atmen Pflanzen ein?', answers: [{text: 'Sauerstoff', isCorrect: false}, {text: 'Kohlendioxid', isCorrect: true}, {text: 'Stickstoff', isCorrect: false}]},
    { question: 'Wie viele BundeslÃ¤nder hat Deutschland?', answers: [{text: '15', isCorrect: false}, {text: '16', isCorrect: true}, {text: '17', isCorrect: false}]},
    { question: 'Welches Tier ist auf dem Porsche-Logo abgebildet?', answers: [{text: 'LÃ¶we', isCorrect: false}, {text: 'Pferd', isCorrect: true}, {text: 'Stier', isCorrect: false}]},
    { question: 'Wie viele Sekunden hat eine Stunde?', answers: [{text: '3600', isCorrect: true}, {text: '60', isCorrect: false}, {text: '360', isCorrect: false}]},
    { question: 'Welche Farbe hat eine "Black Box" in einem Flugzeug?', answers: [{text: 'Schwarz', isCorrect: false}, {text: 'Orange', isCorrect: true}, {text: 'Rot', isCorrect: false}]},
    { question: 'Wie viele Monde hat der Mars?', answers: [{text: 'Einen', isCorrect: false}, {text: 'Zwei', isCorrect: true}, {text: 'Keinen', isCorrect: false}]},
    { question: 'Welches ist das hÃ¤rteste bekannte natÃ¼rliche Material?', answers: [{text: 'Stahl', isCorrect: false}, {text: 'Diamant', isCorrect: true}, {text: 'Titan', isCorrect: false}]},
    { question: 'Wie viele Oscars gewann der Film "Titanic"?', answers: [{text: '9', isCorrect: false}, {text: '11', isCorrect: true}, {text: '13', isCorrect: false}]},
    { question: 'Welches Land ist das bevÃ¶lkerungsreichste der Welt?', answers: [{text: 'China', isCorrect: false}, {text: 'Indien', isCorrect: true}, {text: 'USA', isCorrect: false}]},
    { question: 'Wie viele Ecken hat ein FÃ¼nfeck?', answers: [{text: '5', isCorrect: true}, {text: '6', isCorrect: false}, {text: '4', isCorrect: false}]},
    { question: 'Welcher Komponist war taub?', answers: [{text: 'Mozart', isCorrect: false}, {text: 'Beethoven', isCorrect: true}, {text: 'Bach', isCorrect: false}]},
    { question: 'Wie viele Pyramiden von Gizeh gibt es?', answers: [{text: '3', isCorrect: true}, {text: '4', isCorrect: false}, {text: '5', isCorrect: false}]},
    { question: 'Welches Meer hat den hÃ¶chsten Salzgehalt?', answers: [{text: 'Mittelmeer', isCorrect: false}, {text: 'Totes Meer', isCorrect: true}, {text: 'Rotes Meer', isCorrect: false}]},
    { question: 'Wie viele BÃ¤nde hat "Der Herr der Ringe"?', answers: [{text: 'Einen', isCorrect: false}, {text: 'Drei', isCorrect: true}, {text: 'Sieben', isCorrect: false}]},
    { question: 'Welche Stadt ist als "Die Stadt der Liebe" bekannt?', answers: [{text: 'Rom', isCorrect: false}, {text: 'Paris', isCorrect: true}, {text: 'Venedig', isCorrect: false}]},
];

// --- Animations-Hook ---
const useAnimation = () => {
    const [animatedPawn, setAnimatedPawn] = useState(null);
    const triggerCaptureAnimation = (player, index) => {
        setAnimatedPawn({ player, index, state: 'captured' });
        setTimeout(() => setAnimatedPawn(null), 500);
    };
    return { animatedPawn, triggerCaptureAnimation };
};

// --- Komponenten ---

const Pawn = ({ color, isHighlighted, animationState, isSelectable }) => {
    const animationClass = animationState === 'captured' ? 'animate-shake' : '';
    const highlightStyle = isHighlighted || isSelectable ? { filter: 'drop-shadow(0 0 6px #fff)' } : {};
    const selectableStyle = isSelectable ? { filter: 'drop-shadow(0 0 8px #a855f7)' } : {};
    // BUGFIX: Use a dark stroke for the yellow pawn's head for visibility
    const headStrokeColor = color.toLowerCase() === 'yellow' ? '#4b5563' : '#ffffff';

    return (
      <div className={`w-full h-full transition-all duration-300 ${isHighlighted ? 'scale-110' : ''} ${animationClass}`} style={{...highlightStyle, ...selectableStyle}}>
        <svg viewBox="0 0 100 120" className="w-full h-full">
            <defs>
                <radialGradient id={`grad-${color}`} cx="50%" cy="40%" r="50%" fx="50%" fy="30%">
                    <stop offset="0%" style={{stopColor: '#ffffff', stopOpacity: 0.7}} />
                    <stop offset="100%" style={{stopColor: color, stopOpacity: 1}} />
                </radialGradient>
                <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                    <feDropShadow dx="2" dy="4" stdDeviation="2.5" floodColor="#000" floodOpacity="0.3"/>
                </filter>
            </defs>
            <g style={{filter: 'url(#shadow)'}}>
                {/* Body of the pawn, adjusted for the new viewbox */}
                <path d="M 50,118 C 20,118 10,100 10,100 L 25,60 C 25,60 15,40 50,15 C 85,40 75,60 75,60 L 90,100 C 90,100 80,118 50,118 Z" fill={`url(#grad-${color})`} stroke="#000" strokeWidth="2"/>
                {/* Head of the pawn */}
                <circle cx="50" cy="35" r="18" fill={color} stroke={headStrokeColor} strokeWidth="3" />
            </g>
        </svg>
      </div>
    );
};

const Cell = ({ type, color, children, isEvent, isQuiz }) => {
  const baseClasses = "w-9 h-9 md:w-10 md:h-10 rounded-md transition-colors duration-200 relative";
  let styleClasses = '';
  switch (type) {
    case 'path': styleClasses = 'bg-stone-200 shadow-inner'; break;
    case 'start_cell': styleClasses = `bg-gradient-to-br from-${color}-300 to-${color}-400 shadow-inner`; break;
    case 'start_area': styleClasses = `bg-${color}-100 border-2 border-dashed border-${color}-300`; break;
    case 'finish': styleClasses = `bg-gradient-to-br from-${color}-200 to-${color}-300 shadow-inner`; break;
    case 'empty': styleClasses = 'bg-transparent pointer-events-none'; break;
    default: styleClasses = 'bg-gray-100';
  }

  return (
    <div className={`${baseClasses} ${styleClasses}`}>
      {isEvent && <LucideStar className="absolute text-yellow-400 opacity-80" style={{filter: 'drop-shadow(0 0 3px #000)'}} size={24} />}
      {isQuiz && <LucideHelpCircle className="absolute text-purple-400 opacity-90" style={{filter: 'drop-shadow(0 0 3px #000)'}} size={24} />}
      <div className="relative z-10 w-full h-full">{children}</div>
    </div>
  );
};

const Dice = ({ value, onRoll, isRolling, canRoll }) => (
  <button onClick={onRoll} disabled={!canRoll || isRolling} className={`w-24 h-24 bg-white rounded-2xl shadow-2xl flex items-center justify-center text-6xl font-bold text-gray-800 transform transition-transform duration-300 ${canRoll ? 'hover:scale-110 hover:rotate-6' : 'opacity-50 cursor-not-allowed'} ${isRolling ? 'animate-spin' : ''}`}>
    {isRolling ? <LucideDices className="animate-ping" /> : value}
  </button>
);

const EventSlotMachine = ({ onFinish }) => {
    const [isSpinning, setIsSpinning] = useState(true);
    const [finalEvent, setFinalEvent] = useState(null);
    const reelRef = useRef(null);
    const repeatedEvents = useRef([...EVENTS, ...EVENTS, ...EVENTS, ...EVENTS, ...EVENTS]).current;

    const stopSpinning = () => {
        if (!isSpinning) return;
        setIsSpinning(false);
        const eventIndex = Math.floor(Math.random() * EVENTS.length);
        const chosenEvent = EVENTS[eventIndex];
        const elementHeight = 80;
        const targetSetIndex = 2; 
        const finalElementIndex = (targetSetIndex * EVENTS.length) + eventIndex;
        const finalPosition = finalElementIndex * elementHeight;
        if (reelRef.current) {
            reelRef.current.style.transition = 'transform 3s cubic-bezier(0.25, 1, 0.5, 1)';
            reelRef.current.style.transform = `translateY(-${finalPosition}px)`;
        }
        setTimeout(() => { setFinalEvent(chosenEvent); }, 3000);
    };
    
    useEffect(() => {
        if(finalEvent) { setTimeout(() => onFinish(finalEvent), 2500); }
    }, [finalEvent, onFinish]);

    return (
        <div className="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div className="bg-gradient-to-b from-gray-700 to-gray-900 rounded-2xl shadow-2xl p-6 text-center max-w-sm w-full border-4 border-yellow-400">
                <h2 className="text-3xl font-bold text-white mb-4">Ereignisfeld!</h2>
                <div className="h-20 w-full bg-gray-800 rounded-lg overflow-hidden relative border-2 border-gray-500 my-4">
                    <div ref={reelRef} className={`flex flex-col items-center justify-center ${isSpinning ? 'animate-slot-machine' : ''}`}>{repeatedEvents.map((event, i) => (<div key={i} className="h-20 flex items-center justify-center text-6xl">{event.emoji}</div>))}</div>
                    <div className="absolute inset-0 bg-gradient-to-t from-gray-800 via-transparent to-gray-800"></div>
                    <div className="absolute top-1/2 left-0 w-full h-px -translate-y-1/2 bg-red-500 opacity-50"></div>
                </div>
                {finalEvent ? (<div className="h-24 flex flex-col items-center justify-center"><p className="text-2xl font-bold text-yellow-400 animate-pulse">{finalEvent.name}</p><p className="text-white mt-2">{finalEvent.description}</p></div>) : (<button onClick={stopSpinning} disabled={!isSpinning} className="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-8 rounded-full text-2xl transition-all transform hover:scale-105 disabled:opacity-50">STOP</button>)}
            </div>
        </div>
    );
};

const QuizModal = ({ question, onAnswer }) => {
    const [answered, setAnswered] = useState(false);
    const [result, setResult] = useState(null); // 'correct' or 'incorrect'

    const handleAnswerClick = (answer) => {
        if (answered) return;
        setAnswered(true);
        if (answer.isCorrect) {
            setResult('correct');
        } else {
            setResult('incorrect');
        }
        setTimeout(() => onAnswer(answer.isCorrect), 2000);
    };

    return (
        <div className="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4">
            <div className="bg-white rounded-2xl shadow-2xl p-8 text-center max-w-md w-full">
                <LucideHelpCircle className="mx-auto text-purple-500 mb-4" size={48} />
                <h2 className="text-2xl font-bold text-gray-800 mb-4">SchÃ¤tzfrage!</h2>
                <p className="text-lg text-gray-600 mb-6 min-h-[56px]">{question.question}</p>
                <div className="space-y-3">
                    {question.answers.map((ans, i) => (
                        <button 
                            key={i} 
                            onClick={() => handleAnswerClick(ans)}
                            disabled={answered}
                            className={`w-full p-4 rounded-lg font-semibold text-lg transition-all duration-300
                                ${!answered ? 'bg-gray-200 hover:bg-purple-200' : ''}
                                ${answered && ans.isCorrect ? 'bg-green-500 text-white scale-105' : ''}
                                ${answered && !ans.isCorrect ? 'bg-red-500 text-white' : ''}
                                ${answered ? 'opacity-70' : ''}
                            `}
                        >
                            {ans.text}
                        </button>
                    ))}
                </div>
                {result === 'correct' && <p className="mt-4 text-xl font-bold text-green-600 animate-pulse">Richtig! Du gehst 4 Felder vor.</p>}
                {result === 'incorrect' && <p className="mt-4 text-xl font-bold text-red-600 animate-pulse">Falsch! Du gehst 2 Felder zurÃ¼ck.</p>}
            </div>
        </div>
    );
};

const LudoGame = ({ onBack, players: playerConfig }) => {
  if (!playerConfig || playerConfig.length === 0) return null;

  const [pawns, setPawns] = useState(() => initializePawnState());
  const [diceValue, setDiceValue] = useState(0);
  const [activePlayers, setActivePlayers] = useState(() => playerConfig.map(p => p.color));
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [isRolling, setIsRolling] = useState(false);
  const [message, setMessage] = useState(() => `${playerConfig[0].name}, bitte wÃ¼rfeln!`);
  const [winner, setWinner] = useState(null);
  const [rollAttempts, setRollAttempts] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);
  const { animatedPawn, triggerCaptureAnimation } = useAnimation();
  
  const [showEventModal, setShowEventModal] = useState(false);
  const [showQuizModal, setShowQuizModal] = useState(false);
  const [currentQuestion, setCurrentQuestion] = useState(null);
  const [eventPawn, setEventPawn] = useState(null);
  const [gameState, setGameState] = useState('normal');

  const currentPlayerColor = activePlayers[currentPlayerIndex];
  const currentPlayerName = playerConfig.find(p => p.color === currentPlayerColor).name;

  function initializePawnState() {
    const state = {};
    playerConfig.forEach(({ color }) => {
      state[color] = START_POSITIONS[color].map(pos => ({ position: pos, state: 'home' }));
    });
    return state;
  }

  const nextPlayer = () => {
    const nextIndex = (currentPlayerIndex + 1) % activePlayers.length;
    setCurrentPlayerIndex(nextIndex);
    setDiceValue(0);
    setRollAttempts(0);
    const nextPlayerName = playerConfig.find(p => p.color === activePlayers[nextIndex]).name;
    setMessage(`${nextPlayerName}, bitte wÃ¼rfeln!`);
  };

  const handleRollDice = () => {
    if (gameState !== 'awaitingChaosRoll' && (winner || isRolling || diceValue !== 0 || isAnimating || showEventModal || showQuizModal)) return;
    if (gameState === 'awaitingChaosRoll' && isRolling) return;

    setIsRolling(true);
    setMessage('');
    setTimeout(() => {
      const roll = Math.floor(Math.random() * 6) + 1;
      setIsRolling(false);

      if (gameState === 'awaitingChaosRoll') {
          setDiceValue(roll);
          setGameState('chaosMovePending');
          setMessage('WÃ¤hle die Chaos-Figur zum Ziehen.');
          return;
      }
      
      setDiceValue(roll);
      
      const allPawnsHome = pawns[currentPlayerColor].every(p => p.state === 'home');
      const newAttempts = rollAttempts + 1;

      if (allPawnsHome && roll !== 6) {
        if (newAttempts < 3) {
          setRollAttempts(newAttempts);
          setMessage(`Versuch ${newAttempts}/3. WÃ¼rfle nochmal!`);
          setDiceValue(0);
        } else {
          setMessage(`${currentPlayerName} konnte nicht rauskommen.`);
          setTimeout(nextPlayer, 1500);
        }
        return;
      }
      
      const movablePawns = getMovablePawns(currentPlayerColor, roll);
      if (movablePawns.length === 0) {
        setMessage(`${currentPlayerName} kann nicht ziehen.`);
        setTimeout(() => (roll !== 6) ? nextPlayer() : (setMessage("6 gewÃ¼rfelt, aber kein Zug mÃ¶glich. WÃ¼rfle nochmal!"), setDiceValue(0)), 1500);
      } else {
        setMessage("WÃ¤hle eine Figur zum Ziehen.");
      }
    }, 1000);
  };

  const getMovablePawns = (player, roll) => {
    if (gameState === 'chaosMovePending') {
        if (eventPawn && eventPawn.player === player) {
            return [pawns[player][eventPawn.index]].map((p, i) => ({...p, index: eventPawn.index}));
        }
        return [];
    }
    const playerPawns = pawns[player];
    const startCell = PATH_START_CELL[player];
    const pawnOnStart = playerPawns.find(p => p.position === startCell && p.state === 'path');
    if (pawnOnStart) return [{ ...pawnOnStart, index: playerPawns.indexOf(pawnOnStart) }];
    const pawnsAtHome = playerPawns.filter(p => p.state === 'home');
    if (roll === 6 && pawnsAtHome.length > 0) return pawnsAtHome.map(pawn => ({...pawn, index: playerPawns.indexOf(pawn)}));
    return playerPawns.map((pawn, index) => {
        if (pawn.state === 'home') return null;
        if (pawn.state === 'finish') {
            const currentFinishIdx = FINISH_LINE_CELLS[player].indexOf(pawn.position);
            const newFinishIdx = currentFinishIdx + roll;
            if (newFinishIdx >= FINISH_LINE_CELLS[player].length) return null;
            for (let i = currentFinishIdx + 1; i <= newFinishIdx; i++) {
                if (playerPawns.some(p => p.position === FINISH_LINE_CELLS[player][i])) return null;
            }
        }
        return { ...pawn, index };
    }).filter(p => p !== null);
  };

  const performCapture = async (newPawns, landingPosition, currentPlayer) => {
    for (const otherColor of activePlayers) {
        if (otherColor !== currentPlayer) {
            for (let otherIndex = 0; otherIndex < newPawns[otherColor].length; otherIndex++) {
                const otherPawn = newPawns[otherColor][otherIndex];
                if (otherPawn.position === landingPosition && otherPawn.state === 'path') {
                    triggerCaptureAnimation(otherColor, otherIndex);
                    await new Promise(res => setTimeout(res, 500));
                    newPawns[otherColor][otherIndex] = { position: START_POSITIONS[otherColor][otherIndex], state: 'home' };
                    setMessage(`${currentPlayerName} hat einen Stein von ${playerConfig.find(p=>p.color===otherColor).name} geschlagen!`);
                    return newPawns;
                }
            }
        }
    }
    return newPawns;
  };

  const movePawnBySteps = async (player, pawnIndex, steps) => {
    setIsAnimating(true);
    let tempPawns = JSON.parse(JSON.stringify(pawns));
    let pawnToMove = tempPawns[player][pawnIndex];
    const currentPathIndex = PATH.indexOf(pawnToMove.position);
    const stepsFromStart = (currentPathIndex - PATH_START_INDEX[player] + 40) % 40;
    const newStepsFromStart = stepsFromStart + steps;
    const newPathIndex = (PATH_START_INDEX[player] + newStepsFromStart + 40) % 40;
    pawnToMove.position = PATH[newPathIndex];
    tempPawns = await performCapture(tempPawns, pawnToMove.position, player);
    setPawns(tempPawns);
    setIsAnimating(false);
    setTimeout(nextPlayer, 1000);
  };

  const handleEventEffect = async (event) => {
      setShowEventModal(false);
      const { player, index } = eventPawn;
      switch(event.effect) {
          case 'fly': await movePawnBySteps(player, index, 5); break;
          case 'police': await movePawnBySteps(player, index, -3); break;
          case 'chaos': setGameState('awaitingChaosRoll'); setMessage(`${currentPlayerName}, wÃ¼rfle fÃ¼r den Chaos-Effekt!`); setDiceValue(0); break;
          case 'swap':
              let swappablePawnsExist = false;
              for (const pColor of activePlayers) {
                  for (let pIndex = 0; pIndex < pawns[pColor].length; pIndex++) {
                      const pawn = pawns[pColor][pIndex];
                      if ((pColor !== player || pIndex !== index) && (pawn.state === 'path' || pawn.state === 'finish')) {
                          swappablePawnsExist = true;
                          break;
                      }
                  }
                  if (swappablePawnsExist) break;
              }
              if (swappablePawnsExist) {
                  setGameState('awaitingSwap');
                  setMessage(`${currentPlayerName}, wÃ¤hle eine Figur zum Tauschen!`);
              } else {
                  setMessage("Kein Tausch mÃ¶glich, da keine anderen Figuren auf dem Feld sind!");
                  setTimeout(nextPlayer, 2000);
              }
              break;
          default: nextPlayer();
      }
  };
  
  const handleQuizAnswer = async (isCorrect) => {
      setShowQuizModal(false);
      setCurrentQuestion(null);
      const { player, index } = eventPawn;
      const steps = isCorrect ? 4 : -2;
      await movePawnBySteps(player, index, steps);
  };

  const handleSwap = (targetPlayer, targetIndex) => {
      if (gameState !== 'awaitingSwap') return;
      const sourcePawn = pawns[eventPawn.player][eventPawn.index];
      const targetPawn = pawns[targetPlayer][targetIndex];
      if (sourcePawn.position === targetPawn.position) return;
      setIsAnimating(true);
      let newPawns = JSON.parse(JSON.stringify(pawns));
      newPawns[eventPawn.player][eventPawn.index] = { position: targetPawn.position, state: targetPawn.state };
      newPawns[targetPlayer][targetIndex] = { position: sourcePawn.position, state: sourcePawn.state };
      setPawns(newPawns);
      setTimeout(() => { setIsAnimating(false); setGameState('normal'); nextPlayer(); }, 500);
  };

  const animateAndMovePawn = async (player, pawnIndex, roll) => {
    if (player !== currentPlayerColor || isRolling || winner || isAnimating) return;
    if (gameState === 'chaosMovePending') {
        if (pawnIndex !== eventPawn.index) { setMessage("Du musst die Figur bewegen, die das Ereignis ausgelÃ¶st hat."); return; }
        const direction = roll % 2 === 0 ? 1 : -1;
        const steps = roll * direction;
        setGameState('normal');
        await movePawnBySteps(player, pawnIndex, steps);
        return;
    }
    if (diceValue === 0) return;
    const movablePawns = getMovablePawns(player, roll);
    if (!movablePawns.some(p => p.index === pawnIndex)) return setMessage("Dieser Spielstein kann nicht bewegt werden.");
    
    setIsAnimating(true);
    setMessage('');
    const pawnToMove = pawns[player][pawnIndex];
    let pathOfAnimation = [], finalState = { ...pawnToMove };
    if (pawnToMove.state === 'home' && roll === 6) {
        pathOfAnimation.push(PATH_START_CELL[player]);
        finalState = { position: PATH_START_CELL[player], state: 'path' };
    } else if (pawnToMove.state === 'path') {
        const currentPathIndex = PATH.indexOf(pawnToMove.position);
        const stepsFromStart = (currentPathIndex - PATH_START_INDEX[player] + 40) % 40;
        for (let i = 1; i <= roll; i++) {
            const nextSteps = stepsFromStart + i;
            if (nextSteps >= 40) {
                const stepsIntoFinish = nextSteps - 40;
                if (stepsIntoFinish < FINISH_LINE_CELLS[player].length) pathOfAnimation.push(FINISH_LINE_CELLS[player][stepsIntoFinish]);
            } else pathOfAnimation.push(PATH[(PATH_START_INDEX[player] + nextSteps) % 40]);
        }
        finalState = { position: pathOfAnimation.length > 0 ? pathOfAnimation[pathOfAnimation.length - 1] : pawnToMove.position, state: pathOfAnimation.some(p => FINISH_LINE_CELLS[player].includes(p)) ? 'finish' : 'path' };
    } else if (pawnToMove.state === 'finish') {
        const currentFinishIndex = FINISH_LINE_CELLS[player].indexOf(pawnToMove.position);
        for(let i = 1; i <= roll; i++) pathOfAnimation.push(FINISH_LINE_CELLS[player][currentFinishIndex + i]);
        finalState = { position: pathOfAnimation.length > 0 ? pathOfAnimation[pathOfAnimation.length - 1] : pawnToMove.position, state: 'finish' };
    }
    
    // BUGFIX: Verhindern, auf eigenen Figuren zu landen
    const isOccupiedBySelf = pawns[player].some(
        (p, i) => i !== pawnIndex && p.position === finalState.position
    );
    if (isOccupiedBySelf) {
        setMessage("Du kannst nicht auf einer eigenen Figur landen.");
        setIsAnimating(false);
        return;
    }

    for (const pos of pathOfAnimation) {
        setPawns(prev => ({ ...prev, [player]: prev[player].map((p, i) => i === pawnIndex ? { ...p, position: pos } : p) }));
        await new Promise(res => setTimeout(res, 200));
    }
    let finalPawns = JSON.parse(JSON.stringify(pawns));
    finalPawns[player][pawnIndex] = finalState;
    if (finalState.state === 'path') { finalPawns = await performCapture(finalPawns, finalState.position, player); }
    setPawns(finalPawns);
    setIsAnimating(false);
    if (finalPawns[player].every(p => p.state === 'finish')) { setWinner(player); return setMessage(`ðŸŽ‰ ${currentPlayerName} hat gewonnen! ðŸŽ‰`); }
    
    setEventPawn({ player, index: pawnIndex });
    if (EVENT_FIELDS.includes(finalState.position)) { setShowEventModal(true); return; }
    if (QUIZ_FIELDS.includes(finalState.position)) { 
        setCurrentQuestion(QUIZ_QUESTIONS[Math.floor(Math.random() * QUIZ_QUESTIONS.length)]);
        setShowQuizModal(true); 
        return; 
    }
    
    if (roll !== 6) nextPlayer();
    else { setMessage("6 gewÃ¼rfelt! WÃ¼rfle nochmal."); setDiceValue(0); setRollAttempts(0); }
  };
  
  const boardCells = [];
  for (let i = 0; i < 121; i++) {
    let type = 'empty', color = '', children = null;
    if (PATH.includes(i)) type = 'path';
    if (Object.values(START_POSITIONS).flat().includes(i)) type = 'start_area';
    if (Object.values(FINISH_LINE_CELLS).flat().includes(i)) type = 'finish';
    COLORS.forEach(c => {
      if (START_POSITIONS[c].includes(i)) color = c;
      if (FINISH_LINE_CELLS[c].includes(i)) color = c;
      if (PATH_START_CELL[c] === i) { type = 'start_cell'; color = c; }
    });
    for (const pColor of activePlayers) {
      if(pawns[pColor]) {
        pawns[pColor].forEach((pawn, pawnIndex) => {
          if (pawn.position === i) {
            const isMovable = getMovablePawns(pColor, diceValue).some(mp => mp.index === pawnIndex);
            // BUGFIX: Korrekte Logik fÃ¼r die Auswahl eines Tauschziels
            const isSelectableForSwap = gameState === 'awaitingSwap' && pColor !== currentPlayerColor && (pawn.state === 'path' || pawn.state === 'finish');
            const animState = animatedPawn && animatedPawn.player === pColor && animatedPawn.index === pawnIndex ? animatedPawn.state : null;
            
            const pawnOnClick = () => {
                if (gameState === 'awaitingSwap') {
                    if (isSelectableForSwap) {
                        handleSwap(pColor, pawnIndex);
                    }
                } else {
                    animateAndMovePawn(pColor, pawnIndex, diceValue);
                }
            };
            
            children = (
              <div className="absolute w-10 h-12 bottom-0 left-1/2 -translate-x-1/2 cursor-pointer z-20" onClick={pawnOnClick}>
                <Pawn color={pColor} isHighlighted={pColor === currentPlayerColor && isMovable && !isAnimating} animationState={animState} isSelectable={isSelectableForSwap} />
              </div>
            );
          }
        });
      }
    }
    boardCells.push(<Cell key={i} type={type} color={color} isEvent={EVENT_FIELDS.includes(i)} isQuiz={QUIZ_FIELDS.includes(i)}>{children}</Cell>);
  }

  return (
    <div className="p-2 md:p-4 flex flex-col items-center justify-center w-full min-h-screen bg-gray-100">
      {showEventModal && <EventSlotMachine onFinish={handleEventEffect} />}
      {showQuizModal && currentQuestion && <QuizModal question={currentQuestion} onAnswer={handleQuizAnswer} />}
      {winner && <MessageBox message={message} onConfirm={onBack} />}
      <div className="w-full max-w-5xl flex flex-col lg:flex-row items-center lg:items-start justify-around gap-4">
        <div className="grid grid-cols-11 gap-1 bg-gray-400 p-2 md:p-3 rounded-2xl shadow-lg"> {boardCells} </div>
        <div className="flex flex-col items-center gap-4 p-6 bg-white/80 backdrop-blur-sm rounded-2xl shadow-lg w-full max-w-xs">
          <h2 className="text-2xl font-bold text-gray-700">Am Zug:</h2>
          <div className="flex items-center gap-4 p-3 rounded-full" style={{backgroundColor: `${currentPlayerColor}33`}}>
            <div className="w-8 h-8 rounded-full" style={{backgroundColor: currentPlayerColor}}></div>
            <span className="text-2xl font-bold truncate" style={{color: currentPlayerColor}}>{currentPlayerName}</span>
          </div>
          <Dice value={diceValue || '?'} onRoll={handleRollDice} isRolling={isRolling} canRoll={!isRolling && !winner && !isAnimating && !showEventModal && !showQuizModal} />
          <p className="text-md text-gray-600 h-10 text-center px-2">{message}</p>
          <button onClick={onBack} className="mt-4 flex items-center gap-2 text-gray-600 hover:text-blue-600 transition-colors"><LucideArrowLeft size={18} />ZurÃ¼ck zum Setup</button>
        </div>
      </div>
    </div>
  );
};

const GameSetup = ({ onStartGame }) => {
    const [playerCount, setPlayerCount] = useState(2);
    const [players, setPlayers] = useState([{ name: 'Spieler 1', color: 'red' }, { name: 'Spieler 2', color: 'green' }]);
    useEffect(() => setPlayers(Array.from({ length: playerCount }, (_, i) => ({ name: `Spieler ${i + 1}`, color: COLORS[i] }))), [playerCount]);
    const handleNameChange = (index, newName) => { const updatedPlayers = [...players]; updatedPlayers[index].name = newName; setPlayers(updatedPlayers); };
    return (
        <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full text-center">
            <LucideUsers className="mx-auto text-blue-500 mb-4" size={48} />
            <h2 className="text-3xl font-bold text-gray-800 mb-6">Spiel einrichten</h2>
            <div className="mb-6">
                <label className="block text-lg font-semibold text-gray-700 mb-2">Anzahl der Spieler</label>
                <div className="flex justify-center gap-4">{[2, 3, 4].map(count => (<button key={count} onClick={() => setPlayerCount(count)} className={`w-16 h-16 rounded-full text-2xl font-bold transition-all ${playerCount === count ? 'bg-blue-500 text-white scale-110 shadow-lg' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>{count}</button>))}</div>
            </div>
            <div className="space-y-4 mb-8">{players.map((player, index) => (<div key={player.color} className="flex items-center gap-4"><div className="w-8 h-8 rounded-full" style={{backgroundColor: player.color}}></div><input type="text" value={player.name} onChange={(e) => handleNameChange(index, e.target.value)} className="flex-grow p-2 border-2 border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition"/></div>))}</div>
            <button onClick={() => onStartGame(players)} className="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-8 rounded-full text-xl flex items-center justify-center gap-3 transition-transform transform hover:scale-105"><LucidePlay />Spiel starten</button>
        </div>
    );
};

const App = () => {
  const [gameState, setGameState] = useState('setup'); // 'setup', 'playing'
  const [players, setPlayers] = useState([]);
  const handleStartGame = (playerConfig) => { setPlayers(playerConfig); setGameState('playing'); };
  const handleBackToSetup = () => { setGameState('setup'); setPlayers([]); }
  const renderContent = () => {
    switch(gameState) {
        case 'playing': return <LudoGame onBack={handleBackToSetup} players={players} />;
        case 'setup': default: return <GameSetup onStartGame={handleStartGame} />;
    }
  };
  return (
    <div className="bg-gray-100 min-h-screen w-full flex items-center justify-center font-sans p-4">
      <style>{`
        .animate-slot-machine { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: translateY(0); } to { transform: translateY(-50%); } }
        .animate-shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; } 
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
      `}</style>
      {renderContent()}
    </div>
  );
};

export default App;

